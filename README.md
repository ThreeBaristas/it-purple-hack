# Стэк
- `Golang` для бэка, фреймворк `fiber`
- `React` + `@tanstack/query` + `@tanstack/router` + `shadcn/ui` на фронте
- `PostgreSQL` в качестве БД, в продакшене можно заменить на [ydb](https://ydb.tech)
- `Prometheus` для метрик

# Запуск
Для запуска достаточно поднять docker-контейнеры.

```bash
docker compose up
```

Запускает четыре контейнера:
1. `PostgreSQL` с открытым портом 5432
2. `backend` с открытым портом 3000
3. `front` на `Nginx` с открытым портом 80
4. `Prometheus` для сбора метрик на порту 9090

После этого нужно накатить схему БД:
```bash
psql -h localhost -U postgres -p 5432 -f backend/schema.sql
```

## Наполнение данными
Система будет доступна, однако у нее нет ни настроек стораджа, ни самих матриц.
Для добавления данных нужно либо перейти в веб-интерфейс по адресу
`http://localhost/storage`, либо отправить запрос на API вручную с помощью, например, curl:
```bash
curl 'http://localhost/api/v1/admin/storage' \
  -H 'Content-Type: application/json' \
  --data-raw '{"baseline_matrix_id":0,"discounts":[{"segment_id": 1, "matrix_id": 1}]}'
```

Третий способ - включить переменные, отвечающие за создание таблиц для нагрузочного тестирование.
Для этого необходимо установить переменные `GENERATE_RULES` и `GENERATE_STORAGE` в `true`.
Стоит заметить, что вместо генерации правил цен быстрее накатить дамп, доступный
по [ссылке](https://disk.yandex.ru/d/_OZj0Lh0cVwCmA) с помощью команды
```bash
cat backup.sql | docker exec -i it-purple-hack-postgres-1 psql -U postgres
```


# Нагрузочное тестирование
Методика проведения тестирование следующая:
1. Сначала наполнить таблицу тестовыми данными. Для этого есть метод `PriceService.GenerateRules`. Он был запущен дважды (с изменениями в коде): изначально была сгенерирована baseline-матрица, затем были были равномерно сгенерированы матрицы 1..199. Итого в таблице было 2'180'633 записей для baseline матрицы и 2'218'672 записей для остальных матриц.
2. С помощью инструмента [vegeta](https://github.com/tsenart/vegeta) было проведено нагрузочное тестирование эндпоинта `GET /api/v1/price`. В самом эндпоинте реализована функциональность, записывающая время на ответ в гистограмму Prometheus с линейными корзинами от 50 до 1000 с шагом в 50. Само тестирование проводилось в течение 1 минуты. Значения `category_id`, `location_id` и `user_id` равномерно распределены.
4. Запросы подавались на API напрямую, минуя nginx.
5. Для нахождения 99-го и 95-го перцентиля задержки была использована функция `histogram_quantile(0.99, sum(rate(tb_get_price_request_duration_bucket[1m])) by (le))`

### Параметры машины, на которой запускались тесты:
```
Huawei MateBook D14 2020
AMD Ryzen 7 3700U, 8 cores @ 2.3 GHz, 8GB RAM
Arch Linux, kernel 6.7.9-arch1
```
База данных, Prometheus, бэкенд и vegeta запущены на одной машине.

### Результаты тестирования

| RPS  | Prometheus, 95-th percentile | Prometheus, 99-th percentile | Vegeta, 99-th percentile |
|------|------------------------------|------------------------------|--------------------------|
| 500  | 48.76                        | 49.5                         | 14.8797                  |
| 1000 | 48.7600                      | 255.4146                     | 259.4255                 |
| 1500 | 48.7600                      | 256.5814                     | 263.5857                 |

На RPS выше, чем 1500 начинаются проблемы с высоким ожиданием из-за низкого количества доступных соединений в `ConnectionPool`.
На более мощных системах эта проблемма может быть нивелирована увеличением размера пула и, например, использованием
Managed-решений, например Yandex Managed Service for YDB - в пике эта СУБД может выдерживать до 1 миллиона RPS, причем
ydb может работать в postgres-совместимом режиме.

### Возможные улучшения
- Сейчас конфигурация Storage хранится в той же базе данных, что и таблицы, при этом для нахождения цены сначала происходит отдельный запрос к Storage, что неэффективно и может быть оптимизировано.
- Переехать на `ydb`

# Возможности веб-интерфейса
В веб интерфейсе можно:
1. Просматривать установленные цены на все локации, категории во всех матрицах на главной странице.
2. Добавить новое правило (кнопка `Добавить правило` на главной странице). Если правило с такой категорией, локацией и матрицей уже существует, то оно будет перезаписано.
3. Удалить правило нажатием на красную кнопку на главной странице.
4. Перейти к изменению правила нажатием на соответствующую кнопку.
5. Перейти к странице настройке стораджа. Настраивать сторадж на этой странице.
